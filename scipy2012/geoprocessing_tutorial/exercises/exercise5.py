""" Robustly calculate centroids from real shapefiles

Test 1 should pass already, but test 2 reveals a slight numerical problem :-)
"""

import time
import numpy
from source.core import read_layer
from source.vector import Vector
from source.projection import Projection
from source.utilities import TESTDATA


def calculate_polygon_area(polygon, signed=False):
    """Calculate the signed area of non-self-intersecting polygon

    Input
        polygon: Numeric array of points (longitude, latitude). It is assumed
                 to be closed, i.e. first and last points are identical
        signed: Optional flag deciding whether returned area retains its sign:
                If points are ordered counter clockwise, the signed area
                will be positive.
                If points are ordered clockwise, it will be negative
                Default is False which means that the area is always positive.
    Output
        area: Area of polygon (subject to the value of argument signed)
    """

    # Make sure it is numeric
    P = numpy.array(polygon)

    # Check input
    msg = ('Polygon is assumed to consist of coordinate pairs. '
           'I got second dimension %i instead of 2' % P.shape[1])
    assert P.shape[1] == 2, msg

    msg = ('Polygon is assumed to be closed. '
           'However first and last coordinates are different: '
           '(%f, %f) and (%f, %f)' % (P[0, 0], P[0, 1], P[-1, 0], P[-1, 1]))
    assert numpy.allclose(P[0, :], P[-1, :]), msg

    # Extract x and y coordinates
    x = P[:, 0]
    y = P[:, 1]

    # Area calculation
    a = x[:-1] * y[1:]
    b = y[:-1] * x[1:]
    A = numpy.sum(a - b) / 2.

    # Return signed or unsigned area
    if signed:
        return A
    else:
        return abs(A)


def calculate_polygon_centroid(polygon):
    """Calculate the centroid of non-self-intersecting polygon

    Input
        polygon: Numeric array of points (longitude, latitude). It is assumed
                 to be closed, i.e. first and last points are identical
    Output
        Numeric (1 x 2) array of points representing the centroid
    """

    # Make sure it is numeric
    P = numpy.array(polygon)

    # Exercise: Normalise to ensure numerical accurracy.
    # This requirement in backed by tests and without it
    # centroids at building footprint level may get shifted outside the
    # polygon!

    # Get area - needed to compute centroid
    A = calculate_polygon_area(P, signed=True)

    # Extract x and y coordinates
    x = P[:, 0]
    y = P[:, 1]

    # Compute centroid
    a = x[:-1] * y[1:]
    b = y[:-1] * x[1:]

    cx = x[:-1] + x[1:]
    cy = y[:-1] + y[1:]

    Cx = numpy.sum(cx * (a - b)) / (6. * A)
    Cy = numpy.sum(cy * (a - b)) / (6. * A)

    # Create Nx2 array and return
    # Exercise - renormalise before returning
    C = numpy.array([Cx, Cy])
    return C


def convert_polygons_to_centroids(V):
    """Convert polygon vector data to point vector data

    Input
        V: Vector layer with polygon data

    Output
        Vector layer with point data and the same attributes as V
    """

    msg = 'Input data %s must be polygon vector data' % V
    assert V.is_polygon_data, msg

    geometry = V.get_geometry()
    N = len(V)

    # Calculate centroids for each polygon
    centroids = []
    for i in range(N):
        c = calculate_polygon_centroid(geometry[i])
        centroids.append(c)

    # Create new point vector layer with same attributes and return
    V = Vector(data=V.get_data(),
               projection=V.get_projection(),
               geometry=centroids,
               name='%s_centroid_data' % V.get_name(),
               keywords=V.get_keywords())
    return V

if __name__ == '__main__':

    #-----------------------------
    # Test 1 - a real life dataset
    #-----------------------------

    # Read polygons and calculate centroids
    vectorname = 'kecamatan_geo.shp'
    polygons = read_layer('%s/%s' % (TESTDATA, vectorname))

    c_layer = convert_polygons_to_centroids(polygons)
    c_geometry = c_layer.get_geometry()
    c_layer.write_to_file('calculated_centroids_%s' % vectorname)
    print 'Calculated centroids stored, please review with qgis:'
    print ('qgis spatial_test_data/kecamatan_geo.shp '
           'calculated_centroids_kecamatan_geo.shp '
           'spatial_test_data/kecamatan_geo_centroids.shp')

    # Read reference centroids generated by Qgis
    r_layer = read_layer('%s/%s' % (TESTDATA,
                                    vectorname[:-4] + '_centroids.shp'))
    r_geometry = r_layer.get_geometry()

    msg = 'Centroids of %s were not correct' % vectorname
    assert numpy.allclose(c_geometry, r_geometry, rtol=1.0e-9), msg
    print 'Test 1 passed'
    print

    #---------------------------------------
    # Test 2 - dataset at much smaller scale
    #---------------------------------------

    # Read polygons and calculate centroids
    vectorname = 'OSM_subset.shp'
    polygons = read_layer('%s/%s' % (TESTDATA, vectorname))

    c_layer = convert_polygons_to_centroids(polygons)
    c_geometry = c_layer.get_geometry()
    c_layer.write_to_file('calculated_centroids_%s' % vectorname)
    print 'Calculated centroids stored, please review with qgis:'
    print ('qgis spatial_test_data/OSM_subset.shp '
           'calculated_centroids_OSM_subset.shp '
           'spatial_test_data/OSM_subset_centroids.shp')

    # Read reference centroids generated by Qgis
    r_layer = read_layer('%s/%s' % (TESTDATA,
                                    vectorname[:-4] + '_centroids.shp'))
    r_geometry = r_layer.get_geometry()

    msg = 'Centroids of %s were not correct' % vectorname
    assert numpy.allclose(c_geometry, r_geometry, rtol=1.0e-9), msg
    print 'Test 2 passed'
